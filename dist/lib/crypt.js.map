{"version":3,"sources":["../../src/lib/crypt.js"],"names":["ENC_ALG","IV_LENGTH","encrypt","buffer","encKey","iv","cipher","encrypted","Buffer","concat","update","final","from","toString","encryptP","decrypt","split","map","d","deciper","decryptP","Error","isBuffer","length"],"mappings":";;;;;;;AAAA;;AAEA;;;;;;AAEA;;;;;AAMA;AACA,MAAMA,UAAU,aAAhB;AACA,MAAMC,YAAY,EAAlB;;AAGA;;;;;;AAMO,MAAMC,4BAAU,CAACC,MAAD,EAASC,MAAT,KAAoB;AACzC,QAAMC,KAAK,yBAAYJ,SAAZ,CAAX;AACA,QAAMK,SAAS,4BAAeN,OAAf,EAAwBI,MAAxB,EAAgCC,EAAhC,CAAf;AACA,QAAME,YAAYC,OAAOC,MAAP,CAAc,CAC9BH,OAAOI,MAAP,CAAcP,MAAd,CAD8B,EAE9BG,OAAOK,KAAP,EAF8B,CAAd,CAAlB;AAIA,SAAOH,OAAOI,IAAP,CACJ,GAAEP,GAAGQ,QAAH,CAAY,KAAZ,CAAmB,IAAGN,UAAUM,QAAV,CAAmB,KAAnB,CAA0B,EAD9C,CAAP;AAGD,CAVM;;AAYP;;;;;;AAMO,MAAMC,8BAAW,CAACX,MAAD,EAASC,MAAT,KAAoB,yBAAU,MAAMF,QAAQC,MAAR,EAAgBC,MAAhB,CAAhB,CAArC;;AAGP;;;;;;AAMO,MAAMW,4BAAU,CAACZ,MAAD,EAASC,MAAT,KAAoB;AACzC,QAAM,CAACC,EAAD,EAAKE,SAAL,IAAkBJ,OAAOU,QAAP,GACrBG,KADqB,CACf,GADe,EAErBC,GAFqB,CAEjBC,KAAKV,OAAOI,IAAP,CAAYM,CAAZ,EAAe,KAAf,CAFY,CAAxB;AAGA,QAAMC,UAAU,8BAAiBnB,OAAjB,EAA0BI,MAA1B,EAAkCC,EAAlC,CAAhB;AACA,SAAOG,OAAOC,MAAP,CAAc,CACnBU,QAAQT,MAAR,CAAeH,SAAf,CADmB,EAEnBY,QAAQR,KAAR,EAFmB,CAAd,CAAP;AAID,CATM;;AAWP;;;;;;AAMO,MAAMS,8BAAW,CAACjB,MAAD,EAASC,MAAT,KAAoB,yBAAU,MAAMW,QAAQZ,MAAR,EAAgBC,MAAhB,CAAhB,CAArC;;AAEP;;;;;;;;AAQA;;;;;;;kBAMeA,UAAU;AACvB,MAAI,CAACA,MAAL,EAAa;AACX,UAAM,IAAIiB,KAAJ,CAAU,2BAAV,CAAN;AACD;AACD,MAAI,OAAOjB,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,aAASI,OAAOI,IAAP,CAAYR,MAAZ,CAAT;AACD;AACD,MAAI,CAACI,OAAOc,QAAP,CAAgBlB,MAAhB,CAAL,EAA8B;AAC5B,UAAM,IAAIiB,KAAJ,CAAU,gCAAV,CAAN;AACD;AACD,MAAIjB,OAAOmB,MAAP,KAAkB,EAAtB,EAA0B;AACxB,UAAM,IAAIF,KAAJ,CAAW,sCAAqCjB,OAAOmB,MAAO,8BAA9D,CAAN;AACD;AACD,SAAO;AACLR,aAASZ,UAAUY,QAAQZ,MAAR,EAAgBC,MAAhB,CADd;AAELgB,cAAUjB,UAAUiB,SAASjB,MAAT,EAAiBC,MAAjB,CAFf;AAGLF,aAASC,UAAUD,QAAQC,MAAR,EAAgBC,MAAhB,CAHd;AAILU,cAAUX,UAAUW,SAASX,MAAT,EAAiBC,MAAjB;AAJf,GAAP;AAMD,C","file":"crypt.js","sourcesContent":["import {randomBytes, createCipheriv, createDecipheriv} from 'crypto'\n\nimport asPromise from './as-promise'\n\n/**\n * aes-256-cbc encrypt/decrypt\n * @module lib/crypt\n */\n\n\n// must be 256 Bit (32 characters)\nconst ENC_ALG = 'aes-256-cbc'\nconst IV_LENGTH = 16\n\n\n/**\n * aes-256-cbc encrypt a buffer\n * @param {Buffer} buffer - the buffer to encode\n * @param {String} encKey - the encription key, must be 32 characters (256 Bit) long\n * @returns {Buffer} Buffer containting the iv and the encrypted string\n */\nexport const encrypt = (buffer, encKey) => {\n  const iv = randomBytes(IV_LENGTH)\n  const cipher = createCipheriv(ENC_ALG, encKey, iv)\n  const encrypted = Buffer.concat([\n    cipher.update(buffer),\n    cipher.final()\n  ])\n  return Buffer.from(\n    `${iv.toString('hex')}:${encrypted.toString('hex')}`\n  )\n}\n\n/**\n * aes-256-cbc encrypt a buffer - Promise\n * @param {Buffer} buffer - the buffer to encode\n * @param {String} encKey - the encription key, must be 32 characters (256 Bit) long\n * @returns {Promise} Promise resolving with the encrypted data as Buffer\n */\nexport const encryptP = (buffer, encKey) => asPromise(() => encrypt(buffer, encKey))\n\n\n/**\n * decrypt a aes-256-cbc encrypted buffer\n * @param {Buffer} buffer - the buffer to encode\n * @param {String} encKey - the encription key, must be 32 characters (256 Bit) long\n * @returns {Promise} Promise resolving with the decrypted data as Buffer\n */\nexport const decrypt = (buffer, encKey) => {\n  const [iv, encrypted] = buffer.toString()\n    .split(':')\n    .map(d => Buffer.from(d, 'hex'))\n  const deciper = createDecipheriv(ENC_ALG, encKey, iv)\n  return Buffer.concat([\n    deciper.update(encrypted),\n    deciper.final()\n  ])\n}\n\n/**\n * decrypt a aes-256-cbc encrypted buffer - Promise\n * @param {Buffer} buffer - the buffer to encode\n * @param {String} encKey - the encription key, must be 32 characters (256 Bit) long\n * @returns {Promise} Promise resolving with the decrypted data as Buffer\n */\nexport const decryptP = (buffer, encKey) => asPromise(() => decrypt(buffer, encKey))\n\n/**\n * @typedef {Object} crypt\n * @property {Function} decrypt\n * @property {Function} decryptP\n * @property {Function} encrypt\n * @property {Function} encryptP\n */\n\n/**\n * exports a init function which returns the shorthands for the specific methods\n * without the need of the config object (means the only argument is a buffer)\n * @param  {String} encKey - encryption key\n * @return {crypt} crypt functions\n */\nexport default encKey => {\n  if (!encKey) {\n    throw new Error('encryption key is missing')\n  }\n  if (typeof encKey === 'string') {\n    encKey = Buffer.from(encKey)\n  }\n  if (!Buffer.isBuffer(encKey)) {\n    throw new Error('a Buffer or String is required')\n  }\n  if (encKey.length !== 32) {\n    throw new Error(`invalid encryption key length (is: ${encKey.length} bytes, should be: 32 bytes)`)\n  }\n  return {\n    decrypt: buffer => decrypt(buffer, encKey),\n    decryptP: buffer => decryptP(buffer, encKey),\n    encrypt: buffer => encrypt(buffer, encKey),\n    encryptP: buffer => encryptP(buffer, encKey)\n  }\n}\n"]}