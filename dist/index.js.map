{"version":3,"sources":["../src/index.js"],"names":["crypt","encrypt","data","encKey","deflatedData","level","Z_BEST_COMPRESSION","encryptedDeflatedData","encryptP","deflatedEncryptedDeflatedData","encodedDeflatedEncryptedDeflatedData","encryptSync","decrypt","string","toString","decryptP","decryptSync","decrypted","isString","defaultIsString","Error","Buffer","from","isBuffer","length"],"mappings":"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","file":"index.js","sourcesContent":["import {Z_BEST_COMPRESSION} from 'zlib'\n\nimport * as crypt from './lib/crypt'\nimport {parse, parseP, stringify, stringifyP} from './lib/json'\nimport {deflate, deflateSync, inflate, inflateSync} from './lib/zlib'\nimport {encode, encodeP, decode, decodeP} from './lib/base64-urlsafe'\n\n/**\n * encrypts, encodes and deflates a given object/string\n *\n * Encryption Process:\n *  1. stringify data (optional)\n *  2. deflate\n *  3. encrypt\n *  4. deflate\n *  5. urlsafe base64 encode\n *\n * Decryption Process:\n *  1. urlsafe base64 decode\n *  2. inflate\n *  3. decrypt\n *  4. inflate\n *  5. parse data (optional)\n *\n * ## Installation\n * `npm install --save git+https:github.com/freshfx/rbcp3-urlsafe-crypto.git#v1.0.1`\n *\n * @module urlsafe-crypto\n */\n\n/**\n * encrypts and encodes a given object or string\n * @example\n * const ENC_KEY = '6b7beea8ef24f7ee89e153387db8f04f'\n * // should print something like 'eJwNzAcBA0EIADBLbI66YfqX8I2ACCUcg2dSRseFKzIYpAtXM_yWN9_sDVwk9lxORTkS6op3FHdJdOmqnTI1rbrJP-FnD-wDMqcaoQ'\n * encrypt({key: 'value'}, ENC_KEY).then(result => console.log(result))\n * @param  {Object|String} data the data to encrypt\n * @param  {String} encKey Encryption Key, length must be 32 (256 Bit)\n * @return {Promise} Promise which resolves with the resulting String\n */\nexport const encrypt = async (data, encKey) => {\n  if (typeof data === 'object') {\n    data = await stringifyP(data)\n  }\n\n  const deflatedData = await deflate(data, {level: Z_BEST_COMPRESSION})\n  const encryptedDeflatedData = await crypt.encryptP(deflatedData, encKey)\n  const deflatedEncryptedDeflatedData = await deflate(encryptedDeflatedData, {level: Z_BEST_COMPRESSION})\n  const encodedDeflatedEncryptedDeflatedData = await encodeP(deflatedEncryptedDeflatedData)\n  return encodedDeflatedEncryptedDeflatedData\n}\n\n/**\n * encrypts and encodes a given object or string - synchronously\n * @example\n * const ENC_KEY = '6b7beea8ef24f7ee89e153387db8f04f'\n * // should print something like 'eJwNzAcBA0EIADBLbI66YfqX8I2ACCUcg2dSRseFKzIYpAtXM_yWN9_sDVwk9lxORTkS6op3FHdJdOmqnTI1rbrJP-FnD-wDMqcaoQ'\n * console.log(encrypt({key: 'value'}, ENC_KEY))\n * @param  {Object|String} data the data to encrypt\n * @param  {String} encKey Encryption Key, length must be 32 (256 Bit)\n * @return {String} the resulting string\n */\nexport const encryptSync = (data, encKey) => {\n  if (typeof data === 'object') {\n    data = stringify(data)\n  }\n\n  return encode(\n    deflateSync(\n      crypt.encrypt(deflateSync(data), encKey),\n      {level: Z_BEST_COMPRESSION}\n    )\n  )\n}\n\n/**\n * decodes and decrypts a given string\n * @example\n * const ENC_KEY = '6b7beea8ef24f7ee89e153387db8f04f'\n * // prints the object'{\"key\": \"value\"}'\n * decrypt('eJwNzAcBA0EIADBLbI66YfqX8I2ACCUcg2dSRseFKzIYpAtXM_yWN9_sDVwk9lxORTkS6op3FHdJdOmqnTI1rbrJP-FnD-wDMqcaoQ', ENC_KEY)\n *   .then(console.log)\n *\n * // prints 'tests'\n * encrypt('test', ENC_KEY).then(result => decrypt(result, ENC_KEY, true)).then(console.log)\n * @param {String} string the data to decode/decrypt\n * @param {String} encKey Encryption Key, length must be 32 (256 Bit)\n * @param {Boolean} toString=false indicates if the result should be converted into a string or object\n * @return {String|Object} the resulting string/object\n */\nexport const decrypt = async (string, encKey, toString = false) => {\n  const deflatedEncryptedDeflatedData = await decodeP(string)\n  const encryptedDeflatedData = await inflate(deflatedEncryptedDeflatedData)\n  const deflatedData = await crypt.decryptP(encryptedDeflatedData, encKey)\n  const data = (await inflate(deflatedData)).toString()\n\n  if (toString === true) {\n    return data\n  }\n  return parseP(data)\n}\n\n/**\n * decodes and decrypts a given string - synchronously\n * @example\n * const ENC_KEY = '6b7beea8ef24f7ee89e153387db8f04f'\n * // prints the object'{\"key\": \"value\"}'\n * console.log(decrypt('eJwNzAcBA0EIADBLbI66YfqX8I2ACCUcg2dSRseFKzIYpAtXM_yWN9_sDVwk9lxORTkS6op3FHdJdOmqnTI1rbrJP-FnD-wDMqcaoQ', ENC_KEY))\n *\n * // prints 'tests'\n * console.log(decrypt(encrypt('test', ENC_KEY), ENC_KEY, true))\n * @param {String} string the data to decode/decrypt\n * @param {String} encKey Encryption Key, length must be 32 (256 Bit)\n * @param {Boolean} toString=false indicates if the result should be converted into a string or object\n * @return {String|Object} the resulting string/object\n */\nexport const decryptSync = (string, encKey, toString = false) => {\n  const decrypted = inflateSync(\n    crypt.decrypt(\n      inflateSync(decode(string)),\n      encKey\n    )\n  ).toString()\n  if (toString === true) {\n    return decrypted\n  }\n  return parse(decrypted)\n}\n\n\n/**\n * @typedef {Object} urlsafe-crypto\n * @property {Function} encrypt\n * @property {Function} encryptSync\n * @property {Function} decrypt\n * @property {Function} decryptSync\n */\n\n\n/**\n * exports a init function which returns the specific methods\n * without the need of the encryption key\n * @example\n * import urlsafeCrypto from 'rbcp3-urlsafe-crypto'\n * const ENC_KEY = 'b6bad4846614652e7ead69df7337a7f4'\n * const crypto = urlsafeCrypto(ENC_KEY)\n *\n * // prints the object\n * crypto.encrypt({an: 'object'}).then(crypto.decrypt).then(console.log)\n * // prints 'test', important: add the isString option to the decrypt function\n * crypto.encrypt('test').then(encryptedString => crypto.decrypt(encryptedString, true)).then(console.log)\n *\n * const cryptoString = urlsafeCrypto(ENC_KEY, true)\n * // prints 'test'\n * cryptoString.encrypt('test').then(crypto.decrypt).then(console.log)\n * // prints the object, important: add the isString option to decrypt function\n * cryptoString.encrypt({an: 'object'}).then(encryptedObject => cryptoString.decrypt(encryptedObject, false)).then(console.log)\n * @param {String} encKey - encryption key\n * @param {Boolean} isString - set the default value for isString (f.e. if you only encrypt/decrypt strings)\n * @return {urlsafe-crypto} urlsafe-crypto functions\n */\nexport default (encKey, isString = false) => {\n  const defaultIsString = isString\n  if (!encKey) {\n    throw new Error('encryption key is missing')\n  }\n  if (typeof encKey === 'string') {\n    encKey = Buffer.from(encKey)\n  }\n  if (!Buffer.isBuffer(encKey)) {\n    throw new Error('a Buffer or String is required')\n  }\n  if (encKey.length !== 32) {\n    throw new Error(`invalid encryption key length (is: ${encKey.length} bytes, should be: 32 bytes)`)\n  }\n  return {\n    decrypt: (data, isString = defaultIsString) => decrypt(data, encKey, isString),\n    decryptSync: (data, isString = defaultIsString) => decryptSync(data, encKey, isString),\n    encrypt: data => encrypt(data, encKey),\n    encryptSync: data => encryptSync(data, encKey)\n  }\n}\n"]}